{-
  Все задачи в этом задании должны решаться исключительно с помощью свёрток.
  Явная рекурсия не допускается. Если в решении в качестве вспомогательной
  требуется стандартная функция обработки списков (помимо fold*, scan*), она
  также должна реализовываться свёрткой.

  Каждое решение должно сопровождаться тремя различными тестовыми примерами, которые при запуске
  возвращают True, например:

  f = undefined -- решение 
  f_test1 = f undefined == undefined -- тест 1
  f_test2 = f undefined == undefined -- тест 2
  f_test3 = f undefined == undefined -- тест 3
-}

{-
 1. Простейшие функции обработки списков
  a) Найти сумму чётных элементов списка с целочисленными элементами.-}
find_sum_even = foldr f 0
	where f x z
		|x `mod` 2==0=x+z
		|otherwise=z
  --b) Найти сумму и произведение элементов списка вещественных чисел.
sum_and_mult = foldl (\(y1,y2) x -> (y1+x,y2*x)) (0,1)
  --с) Найти среднее арифметическое элементов списка вещественных чисел (функцией length пользоваться нельзя,
     --решение должно выполняться в один проход).
find_arithmetic_mean [] = 0
find_arithmetic_mean l= division (foldl (\(y1,y2) x-> (y1+x,y2+1)) (0,0) l)
	where division (x,y) = x/y
  --d) Найти минимальный элемент списка.
find_min_elem (x:xs) = foldl (\x y -> if (x>y) then y else x) x xs
  --e) Найти наименьший нечётный элемент списка с целочисленными значениями (дополнительным параметром
     --функции должно быть значение, возвращаемое по умолчанию).

find_min_odd_elem l p = foldl (step) p l
	where step x y
		|x==p=if(y `mod` 2 /=0)then y else x
		|otherwise=if(y>x)then x else y


{-
 2. Свёртки, формирующие списки
  a) Сформировать список, содержащий каждый второй элемент исходного.
-}

getEverySecond (y:ys) = getSecond' (foldl (step) [(y,0)] ys)
	where step ((x1,x2):xs) x = if(x2==0)then(x,1):((x1,x2):xs)else(x,0):((x1,x2):xs) 
	      getSecond' = foldl (step') []
	      step' z (x,f) = if (f==0) then z else x:z

  --b) Сформировать список, содержащий первые n элементов исходного.
getFirstN (y:ys) n = getFirstN' (foldl (step) [(y,0)] ys)
	where step ((x1,x2):xs) x = (x,x2+1):((x1,x2):xs)
	      getFirstN' = foldl (step') []
	      step' z (x,f) = if (f>=n) then z else x:z
  --c) Сформировать список, содержащий последние n элементов исходного.
getWithoutFirstN (y:ys) n = getLastN' (foldl (step) [(y,0)] ys)
	where step ((x1,x2):xs) x = (x,x2+1):((x1,x2):xs)1
	      getLastN' = foldl (step') []
	      step' z (x,f) = if (f>=n) then x:z else z

listLength [] = 0
listLength (x:xs) = 1+(listLength xs)

getLastN l n = getWithoutFirstN l ((listLength l) - n)
  --d) Сформировать список, содержащий все элементы исходного списка, большие левого соседа.
getElemsGreaterLeftElem (y:ys) = getGreater' (foldl (step) [(y,1)] ys)
	where step ((x1,x2):xs) x = if(x>x1)then(x,1):((x1,x2):xs)else(x,0):((x1,x2):xs)
	      getGreater' = foldl (step') []
	      step' z (x,f) = if (f==1) then x:z else z
  --e) Сформировать список, содержащий все локальные минимумы исходного списка.
getLocalMinimum (y:ys) = getMimimums' (foldl (step) [(y,1)] ys)
	where step ((x1,x2):xs) x = if(x<x1)then(x,1):((x1,x2):xs)else(x,0):((x1,x2):xs)
	      getMimimums' (z:zs) = map (\(x,f)->x) (filter (\(x,f)->f==2) ( foldl (step') [z] zs))
	      step' [(x1,x2)] (x,f) = if (x1>x) then (x,2):[(x1,x2)] else (x,f):[(x1,x2)]
	      step' ((x1,x2):xs) (x,f) = if (f==1)&&(x1>x) then (x,2):((x1,x2):xs) else (x,f):((x1,x2):xs)
  --f) Дана строка, содержащая слова, разделённые одним или несколькими пробелами. Сформировать
     --список слов этой строки.

  --g) Разбить список на непересекающиеся подсписки длиной n элементов.

  --h) Разбить список на подсписки длиной n элементов с перекрывающейся частью в k элементов (k < n).

  --k) Сформировать список, содержащий все начальные элементы списка, удовлетворяющие заданному предикату.

  --l) Повторить каждый элемент списка заданное количество раз.

  --m) Удалить из списка повторяющиеся подряд идущие элементы.

  --n) Даны два списка одинаковой длины. Сформировать список, состоящий из результатов применения
     --заданной функции двух аргументов к соответствующим элементам исходных списков.

{-
 3. Использование свёртки как носителя рекурсии (для запуска свёртки можно использовать список типа [1..n]).
  a) Найти сумму чисел от a до b.
-}
sumAB a b = foldl (\x y -> x+y) 0 (buildList a b)
	where buildList x y
		|x>y=buildList x y
		|otherwise=[x..y]
  --b) Найти сумму факториалов чисел от a до b (повторные вычисления факториалов не допускаются).
{-
factN 0 = 1
factN n = n*(factN (n-1))
factListAB a b = foldr (\(z:zs) x -> (z*x):(z:zs)) [factN a] listAB' (a+1) b
	where listAB' x y = [x..y] 
-}
  --с) Сформировать список из первых n чисел Фибоначчи.

  --d) Пользуясь рядом Тейлора, вычислить значение синуса заданного числа x (использовать
     --n слагаемых).

  --e) Проверить, является ли заданное целое число простым.


{-
 4. Решить задачу о поиске пути с максимальной суммой в треугольнике (см. лекцию 3) при условии,
   что необходимо дополнительно найти сам путь (к примеру, в виде закодированных направлений спуска:
   0 - влево, 1 - вправо). В решении допускается использование любых стандартных функций.
-}

{-
 5. Пусть числовые матрицы представлены списками строк. Реализовать следующие функции:
  1) транспонирование матрицы;
  2) сумма двух матриц;
  3) произведение двух матриц.
-}


{-
 6. Реализовать левую свёртку, пользуясь правой. Проанализировать поведение собственной реализации
  на бесконечных списках и сравнить его с поведением оригинальной foldl.
-}
